import sys
# ==================
# МАТЧАСТЬ
# информация о квартирах хранится в файле csv. одна строка = одна квартира
# первая строка (с индексом 0) - заголовок вот такого вида:
# ID;Количество комнат;Новостройка/вторичка;Метро;Время до метро;Способ;Адрес;Площадь, м2;Этаж;Этажей;Цена;Описание;Балкон;Окна;Санузел;Год постройки;Лифт;Ссылка на объявление
# всего в файле 1 строка-заголовок и 203 строки-квартиры
# ==================
# СПРАВОЧНИК
# списки https://pythonworld.ru/tipy-dannyx-v-python/spiski-list-funkcii-i-metody-spiskov.html
# словари https://pythonworld.ru/tipy-dannyx-v-python/slovari-dict-funkcii-i-metody-slovarej.html
# хорошая статья про f-строки: https://realpython.com/python-f-strings/
# ==================

# РАБОТА СО СТРОКАМИ
# строка - неизменяемый тип, поэтому символы или часть строки получить можно, а вот изменить их напрямую - нельзя.
# для изменения строк есть полезные функции replace() - замена симвлов, split() - разбивка строки по определенному символу, strip() - обрезка пробелов по краям строки, а также join() - соединение нескольких строк в одну через символ-"клей", например, запятую, или просто соединение (строки должны быть представлены в виде списка)
word = "Привет, мир!"
# для изменения символов строки нам придется сначала превратить ее в изменяемый тип - список
word = list(word)
print(word.index("и"))
word[word.index("и")] = "е"
word[word.index("т")] = "д"
word = "".join(word)
word = word.replace("и", "е")
# вот так мы можем решить "в лоб" задачу подсчета количества слов в предложении
words = word.split(" ")
print(words)
for word in words:
	word = word.replace(",", "")
	word = word.replace("!", "")
	word = word.strip()
	print(word)


# РАБОТА СО СПИСКАМИ НА ПРИМЕРЕ ВЫГРУЗКИ КВАРТИР С ЦИАН
# читаем информацию о квартирах в список flats_list. это список списков:
# [[header], [flat1], [flat2], ..., [flatN]]
# подлючаем библиотеку для работы с форматом CSV и читаем данные в переменную flats_list
import csv
flats_list = list()
with open('output.csv', encoding="utf-8") as csvfile:
	flats_csv = csv.reader(csvfile, delimiter=';')
	flats_list = list(flats_csv)

# для работы с данными нам сначала нужно убрать заголовок
# его можно просто удалить безвозвратно. В функцию del необходимо передать тот элемент списка, который нужно удалить.
# flats_list[0], например, удалит первую запись, т.к. заголовок. Причем будет работать и со скобками, и без них
del(flats_list[0])
del flats_list[0]
# либо можно "вынуть" заголовок. т.е. удалить его из flats_list, но при этом сохранить в переменной. В функцию pop передается индекс нужного элемента. pop(0), например, удалит первую запись из списка, но сохранит ее в переменной header
header = flats_list.pop(0)
print(header)

# пустой список можно создать двумя путями:
flats_list = list()
flats_list = []

# имейте в виду, что None - это не пустой список, это тип "ничего", т.е. переменная не инициализирована
# flats_list = None

# узнать, с каким типом данных мы работаем, можно через функцию type()
print(type(flats_list))
if type(flats_list) == list:
	print("Перед нами список!")

# по списку можно "ходить" как из начала в конец, так и из конца в начало. Если бы этого не было, последний элемент списка вы бы получали вот так:
item = flats_list[0][len(flats_list[0])-1]
# но если вы используете отрицательные индексы, вы можете ходить по списку от последнего элемента к первому. -1 - это последний элемент
item = flats_list[0][-1]

# РАБОТА СО СЛОВАРЯМИ НА ПРИМЕРЕ ИНФОРМАЦИИ О КВАРТИРЕ И ГРУППИРОВКИ ПО СТАНЦИИ МЕТРО
subway_dict = {}
for flat in flats_list:
	subway = flat[3].replace("м.", "")
	# помните, что словарь перезапишет информацию по заданному ключу и вас об этом не предупредит.
	# для того, чтобы случайно не перезаписать нужные вам данные, необходимо проверить, не было ли уже такого ключа в словаре.
	# это можно сделать двумя путями: ручной проверкой if key in dictionary.keys() или использовать функцию dictionary.setdefault(), которая сделает проверку за вас:
	# 1) вариант с ручной проверкой
	# if subway not in subway_dict.keys():
	# 	subway_dict[subway] = []
	# 2) вариант с использованием функции setdefault()
	subway_dict.setdefault(subway, [])
	# и мы наконец-то добавляем информацию о квартире к нужной станции метро:
	subway_dict[subway].append(int(flat[11]))

# так можно вывести словарь целиком
print(subway_dict)
# получаем список ключей словаря
keys = subway_dict.keys()
# получаем список значений словаря. обратите внимание - они все равно будут сгруппированы по ключам и поэтому вы получите список списокв
values = subway_dict.values()

# словарь не поддерживает итерацию, т.к. вы не знаете, как Python отсортировал ключи
# чтобы пройти по словарю, используйте один из двух вариантов:
# 1) обычный for с одним значением. ПолучИте ключ и через него - значение ключа:
for k in subway_dict:
	print(f"У метро {k} {len(subway_dict[k])} квартир")
# 2) получИте сразу и ключ, и его значение через функцию dictionary.items():
for k, v in subway_dict.items():
	print(f"У метро {k} {len(v)} квартир")


# ВВОД ИНФОРМАЦИИ С КЛАВИКТУРЫ, РАБОТА С ЦИКЛАМИ И УСЛОВИЯМИ, ПОЛЕЗНЫЕ ФУНКЦИИ СТРОК
# чтобы прочитать данные с клавиатуры, используйте функцию input("пояснение для пользователя")
# помните, что все, что ввели с клавиатуры, - это строка. Если вы хотите получить несколько значений, предупредите пользователя, что, например, нужно вводить их через запятую, а потом используйте функцию разбивки строк split(",")
user_input = ""
while user_input is not "да":
	user_input = input("\nВведите ваш бюджет в рублях. Чтобы закончить, введите да: \n")

	# мы можем сразу привести ввод пользователя к нижнему lower() или верхнему upper() регистру. Тогда нас не волнует, ввел пользователь да, Да, ДА или дА
	if user_input.lower() == "да":
	# if user_input.upper() == "ДА":
		break

	# проверяем, ввел ли пользователь число (все символы - цифры). Если да, нашу строку можно преобразовать в целое число функцией int()
	if user_input.isdigit():
		budget = int(user_input)
	else:
		print(f"Похоже, что {user_input} - это не число. Попробуйте еще раз")
		continue

	count = 0
	# немного про цикл for. Этот цикл не дает вам возможности определить, какой элемент вы в данный момент обрабатываете.
	# чтобы получить индекс элемента, используйте функцию enumerate, которая вернет итератор. Не забудьте добавить еще одну переменную под итератор - у нас это i
	for i, flat in enumerate(flats_list):
		if type(flat[11]) is not int:
			price = int(flat[11])
		else:
			price = flat[11]
		if budget >= price:
			# про вывод на печать. существует минимум три способа это сделать:
			# 1) просто выводить значения подряд вмеремешку с текстом для пользователя. Самое простое, зато код наименее читаемый и в некоторых случаях понадобится прямое приведение типов
			print(i+1, " ", flat[11])
			# 2) вывод через функцию string.format() - в этом случае пишется полный текст сообщения и в нем на заранее запланированные места внутрь {} вставляются значения переменных
			print("{} стоимость: {} руб".format(i+1, flat[11]))
			# 3) f-строки. Все подстановки происходят сразу в тексте сообщения, внутрь {} записывается название переменной. Перед такой строкой должен стоять модификатор f
			print(f"Мы можем себе позволить квартиру №{i+1} стоимостью {flat[11]} руб")
			# 4) бонус: есть старый способ вывода, похожий на вывод в С++: на месте подстановки стоит пара %тип_данных, а список параметров выводится в круглых скобках после %.
			# подробно примеры форматирования можно посмотреть здесь: https://repl.it/@shorstko/Formatirovaniie-chisiel-s-plavaiushchiei-tochkoi
			print("Мы можем себе позволить квартиру %d стоимостью %s руб" % (i+1, flat[11]))
			count += 1
	print(f'{i+1} стоимость: {flat[11]}, единица измерения "руб"')
	print(f"Всего мы можем выкупить {count} квартир")
print("Спасибо за использование нашей програмы, ждем вас снова!")

